<!-- page_number: true -->
<!-- $theme: default -->
<!-- $size: 16:9 -->

FY19 VORTEX FUNトレーニング
Pythonスキルアップチーム勉強会
==

## 第2回
2019.10.17

---

本日のアジェンダ
==

### オブジェクト指向とは
### Pythonをもっともっと知ろう
###  tocaroボット作成講座

---

オブジェクト指向とは
==

---

オブジェクト指向とは
==
# 変更しやすいプログラムを作る手法のこと

---
例えば
==
#### 大規模な業務システムなどは、
- 数百万行のコード　から成り、
- プログラマー　が何十人と関わって、
- 機能拡張やバグ取り　を何度もしながら、
- 数年間　使う。
### 変更しやすいことは、とても重要！！
- これだけのことなのですが「オブジェクト指向」という名前のせいで「なんだかよくわからないもの」になっちゃってます。

---
ちなみに
==
オブジェクト指向の生みの親、アラン・ケイ曰く
![150%](./alankay.jpeg)
「オブジェクト指向（Object Oriented）という名前を付けたのは失敗だった、**メッセージ指向**にすればよかった、、」と悔やんだそうですが、どっちでも同じ未来だった気がします。

---
なお、
==
元宝塚スターの「安蘭けい」とは関係ありません。
![150%](./keiaran.jpg)

---

では早速オブジェクト指向を実践しようか。。。
==
- しかし立ちはだかる謎用語たち
## インスタンス、オーバーライド
## ポリモーフィズム、コンストラクタ
## 抽象クラス、インターフェース
## 継承、インジェクション、カプセル化・・・
# ？？？

---

で、「今更聞けないオブジェクト指向」的なサイトにいくと・・・
==

### クラスとは、インスタンスの設計図で、いわばたい焼きの型のようなものです。インスタンスは、クラスから作られる、たい焼きのようなものなのです！！（ドヤァ）
##### いやいや、クラスからインスタンスができるのは、それはわかるんだけど・・・
- そもそもなぜクラスというものが必要なのかがわからない
- 変更しやすいプログラムを作ることと、たい焼きが結びつかない
#### やっぱりオブジェクト指向ってよくわかんない・・・
## 大丈夫です
## なぜオブジェクト指向が必要なのか、なぜ変更しやすいプログラムが作れるのかを、これから解説いたします

---

今回は、オブジェクト指向３大要素を抑えましょう
==
#### オブジェクト指向３大要素とは
## 継承
## ポリモーフィズム
## カプセル化

---

んじゃ、突然ですがRPGを作ります
==

---
といってもこんなのではなく・・・
==

![80%](./FF13.jpg)

---
レトロなやつ
==
![70%](./dq1.jpg)
こういうのをイメージしてください。
しかも戦闘シーンのみ

---
勇者プロフィール
==

### 勇者じん
- おひつじ座　43歳
```
jin_name = "じん"
jin_hp = 10
jin_lv = 43
jin_str = 5
```
- ステータスはこんな感じ。

---
敵プロフィール
==

### スライム
- 永遠のやられ役
```
slime_name = "スライム"
slime_hp = 5
slime_lv = 1
slime_str = 1
```

---
戦闘プログラム
==

```
jin_name = "じん"
jin_hp = 10
jin_lv = 42
jin_str = 5

slime_name = "スライム"
slime_hp = 5
slime_lv = 1
slime_str = 1

# じんかスライムのどちらかのHPがゼロになるまで繰り返し
while jin_hp > 0 or slime_hp > 0:
 slime_hp = slime_hp - (jin_lv * jin_str)
 jin_hp = jin_hp - (slime_lv * slime_str)

HPが残ってる方の人を表示（処理は省略）
```
> スライム瞬殺ですがあまり気にしないでください。そこは本編とは関係ありません。

---
勇者とスライム以外出てこーへんのかこのゲームは。
==

はっはい対応します。

---
対応しました
==
```
jin_name = "じん"
jin_hp = 10
jin_lv = 42
jin_str = 5

slime_name = "スライム"
slime_hp = 5
slime_lv = 1
slime_str = 1

drakee_name = "ドラキー"
drakee_hp = 7
drakee_lv = 2
drakee_str = 2

ランダムで敵を選ぶ処理（省略）
　じんかスライムのどちらかのHPがゼロになるまで繰り返し：
　じんかドラキーのどちらかのHPがゼロになるまで繰り返し：
　※処理は省略
```

---
全部の敵の処理を書いていくつもりか
==
ですよね ^ ^;

---
勝敗の判定を関数にしてみる
==

```
def 勝敗判定（勇者_name, 勇者_hp,勇者_lv,勇者_str,敵_name, 敵_hp,敵_lv,敵_str）
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵_hp = 敵_hp - (勇者_lv * 勇者_str)
  勇者_hp = 勇者_hp - (敵_lv * 敵_str)
 return 勝った方のname
```
```
jin_hp = 10
※以下省略

slime_hp = 5
※以下省略

drakee_hp = 7
※以下省略

# スライムがあらわれた！
winner = 勝敗判定(jin_name,jin_hp,jin_lv,jin_str,slime_name, sime_hp,slime_lv,slime_str) 
print(winner)
```

---
コードが読みにくい・・・
==
```
winner = 勝敗判定(jin_name,jin_hp,jin_lv,jin_str,slime_name, sime_hp,slime_lv,slime_str) 
```
- 関数に渡す値が多すぎるな・・・と思っていると・・・

---
息を切らしてゲームデザイナーが登場
==

「すみません！防御力のこと忘れてました！ハァハァ」
「・・・（まじか）」

- 防御力の変数(_vit)を追加。

```
def 勝敗判定（勇者_name,勇者_hp,勇者_lv,勇者_str,勇者_vit, 敵_name, 敵_hp,敵_lv,敵_str,敵_vit）
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵_hp = 敵_hp - (勇者_lv * 勇者_str - 敵_vit)
  勇者_hp = 勇者_hp - (敵_lv * 敵_str - 勇者_vit)
```
## 破綻の予感がする
- 「すばやさ」とか他のステータスが増えたらさらに長くなる

---

何が問題かを整理してみる
==
### キャラの数 * ステータスの数だけ変数がある。
- jin_hp、slime_lvなど・・・
### 勝敗判定の関数に渡す値がどんどん増える（あるいは減る）
- 単純にめちゃ見にくい問題
- 引数が変更になった場合、勝敗判定の関数を呼び出す側も、勝敗判定の関数そのものも、両方を変えないといけない。

---

頭のいい人達が考えました
==

## ステータスをひとまとめにした変数「Chara」を作ったらええんや！
```
ひとまとめ Chara {
 name
 hp
 lv
 str
 vit
}
```
### 名付けて「ひとまとめ機能」
- 変数の中に変数が入るイメージ
- キャラのステータスという**個性**をまとめて管理できる。

---
「ひとまとめ機能」を使ってみる
==
- まず、jinとかslimeとかいう名前で使うことを声高らかに宣言

```
Chara jin
Chara slime
```
- その後、各ステータスの値を設定
```
jin.name = "じん"
jin.hp = 10
jin.lv = 43
jin.str = 5
jin.vit = 5

slime.name = "スライム"
slime.hp = 5
slime.lv = 1
※以下略
```

---
使い方は従来と変わらない
==
-  「 _ 」 が「 . 」 になっただけ

```
jin.hp = 10
slime.hp = 5

print(jin.hp) // 10と表示される
print(slime.hp) // 5と表示される
```
- 結局、キャラとステータスの数だけ変数を設定していて、変わったように見えないんだけど・・・

---
勝敗判定の関数に渡す変数が少なくて済む
==
```
// スライムがあらわれた！
勝敗判定(jin,slime)
```
```
def 勝敗判定（勇者,敵）
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵.hp = 敵.hp - (勇者.lv * 勇者.str - 敵.vit)
  勇者.hp = 勇者.hp - (敵.lv * 敵.str - 勇者.vit)
```
- 変数「jin」や「slime」に、全ステータスが入っているのでjinやslimeだけを渡せばOK。
- 各ステータスは「 . 」を使って、関数の中で取り出す。
### 少しマシになったな・・・と思っていると

---
例のデザイナーが走ってきました。
==

「すみません！！剣と鎧のこと忘れてました！ハァハァ」
「・・・（裸か勇者）」
### 大丈夫です。ひとまとめ機能を得てますので

- ひとまとめ機能に、剣と鎧を追加する。
```
ひとまとめ Chara {
 hp
 lv
 str
 vit
 swd // 剣を追加
 arm // 鎧を追加
}
```

---
勝敗判定の関数にも、剣と鎧を追加。でも、、、
==
- 関数の呼び出し側や、受け取る側も、剣と鎧を増やさなくてもいいけど・・・
```
// スライムがあらわれた！
勝敗判定(jin,slime)
```
```
def 勝敗判定（勇者,敵）:
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵.hp = 敵.hp - (勇者.lv * (勇者.str + 勇者.swd) - 敵.lv * (敵.def + 敵.arm))
  勇者.hp = 勇者.hp - (敵.lv * (敵.str + 敵.swd) - 勇者.lv * (勇者.def + 勇者.arm))
```
### これまた破綻の予感
- ダメージの計算は書き換えないといけない
- 「なんとかスキル」とかが増えたらダメージの計算が長くなる。

---
ふと思ふ
==

- キャラの攻撃力や防御力は、HPやレベルと同じで**キャラの個性**。
- キャラの個性を管理している「ひとまとめ」の中で計算してもらって、その結果を貰えばよいのでは？

---
頭のいい人たちが助けてくれた
==
- ひとまとめ機能がパワーアップして、計算ができるようになりました。

```
ひとまとめ Chara {
 hp
 lv
 str
 vit
 swd
 arm

 def 攻撃力() //攻撃力を計算する関数
  return  lv * (str + swd)

 def 防御力() //防御力を計算する関数
  return lv * (vit + arm)
}
```
---
使い方はいままでと同じ
==
- ひとまとめ機能の変数は、以下で利用できた。
```
Chara jin
jin.hp = 10
print(jin.hp) //10と表示される。
```
- 計算の仕方も同じ。
```
jin.swd = 3
print(jin.攻撃力()) //jinの攻撃力 43*(5+3)=344 が表示される。
```
### これでどうなるかというと・・・

---
勝敗判定の関数が見やすくなった
==
```
def 勝敗判定（勇者,敵）:
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵.hp = 敵.hp - (勇者.攻撃力() - 敵.防御力())
  勇者.hp = 勇者.hp - (敵.攻撃力() - 勇者.防御力())
```
#### ごちゃごちゃした計算式がなくなった
- 勝敗判定の関数内で、ダメージを計算するのをやめた
- それぞれのキャラに対して「攻撃力と防御力を教えて」と聞くように変えた

---
見やすくなったのは実はオマケ
==
## 「ダメージの計算」と「勝敗の判定」を分けられたことがポイント
- 攻撃力の計算方法を変えるときは、**攻撃力( )関数**の中身だけを変えればよくなった。
- 勝敗の判定方法を変えることがあったとしても、ダメージの計算部分を気にしなくてよくなった。
## 変更する箇所を狭くすることができた　＝　変更しやすいプログラムになった！！
#### ひとまとめ機能すごい！

---
「ひとまとめ機能」の良さが分かったので
==
## ようやくオブジェクト指向用語の登場
## ひとまとめ機能　＝　クラス
- データ(キャラのステータス)とそれに対する処理（攻撃力と防御力の計算）をまとめたもの
- いわばキャラの「設計図」
```
class Chara {
 name
 hp
 lv
 ...
 def get_atk_point()
 def get_def_point()
 ...
}
```

---
インスタンスとは
==
## クラスに具体的な値を入れたもの
- 1キャラが1インスタンスに相当
- クラス自体はただの設計図なので、具体的な値を持っていない。
- 具体的な値を持ったキャラがほしいときに、インスタンスを新しく作る。
```
jin = new Chara() //Chara jin
jin.hp = 10
jin.lv = 42
```
### メリット
- 勇者とかスライムとか、共通のステータス名を持ったキャラを大量に作れる。　=　**jin_hpとかslime_hpとか、キャラ * ステータスの数だけ変数を持たなくてもよくなる**。

---
たい焼きの例よりわかりやすいんじゃないでしょうか
==

---
そしてお気づきの通り
==

クラス、インスタンスたち　(jin、slime、drakee)
## ↑これらをオブジェクトと呼ぶ
## オブジェクトを使って、変更しやすいプログラムを作る　＝　オブジェクト指向プログラミング
- どこまでをオブジェクトと呼ぶかは言語の仕様によって異なる。例えばpythonでは、関数や変数などの全てが、オブジェクト

---
で、オブジェクト指向言語とは
==
## オブジェクト指向を導入しやすくした言語　＝　オブジェクト指向言語
- オブジェクト指向言語でなくても、頑張ればオブジェクト指向することはできる。
- しかし言語の仕様として無いと、大変めんどくさい・・・
#### さて、オブジェクトが何者かわかったところで一服していると、、、
---
例のデザイナー登場
==

「すいません！魔法のこと忘れてましたァァァ！」
「・・・（魔法忘れるなよ）」

## 安心してください。オブジェクト指向がありますよ。

---
魔道士も簡単にできる
==

```
class Magician extends Chara {
 mp
 matk // 魔法攻撃力
 mdef //魔法防御力

 def get_atk():
  return Chara.lv * Chara.matk
 def get_def():
  return Chara lv * Chara.mdef
}
```
- Charaクラスのステータスを引き継いで（extends）、魔法に必要なステータスだけを定義。
- lvとかhpとか、Charaにあるものはそのまま使える。
- 攻撃力・防御力の計算式は、魔法のステータスを使ったものに変える
	> 関数名が変わってないですが、あとで理由を解説します

---
これぞ「継承」
==
- あるクラスを引き継いで新しいクラスを作ることができる機能
- 新しいクラスに必要になるものだけを追加すればよい
- 同じ名前の関数を書くと、引継元クラスの関数を上書きしてくれる
```
yuto = new Magician()
yuto.hp = 10
...
yuto.mp = 20
yuto.matk = 10
...
print(yuto.get_atk()) //yutoの魔法攻撃力が表示される。
```
## これも「変更しやすい」プログラムを作るための仕組み


---
関数名は変えなくていいんですか
==
```
get_atk()
```
- 戦士の場合・・・武器でぶん殴る。
- 魔道士の場合・・・魔法で焼いたり爆発させたりする。
- 計算方法が違うので、名前も変えたくなりますが・・・
## 方法は異なるが、「相手にダメージを与える」という目的は同じ = 関数名は同じであるべき。

---
攻撃方法によって名前が違うと大変
==
- 魔道士のダメージ計算の関数名を↓な感じにした場合
```
get_magic_atk()
```
- 勝敗判定から呼び出す関数名が変わるので、別の関数を用意しないといけなくなる
```
勇者 = yuto
敵 = slime
def 勇者が魔道士の場合の勝敗判定（勇者,敵）:
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵.hp = 敵.hp - (勇者.get_magic_atk() - 敵.get_def())
  勇者.hp = 勇者.hp - (敵.get_atk() - 勇者.get_def())
```
- キャラの攻撃方法によって勝敗判定の関数を変えないといけないなんて・・・イケてない
## 目的が同じ関数は、中身が違っても同じ名前で呼び出せたほうが便利

---
これぞ「ポリモーフィズム（多態性）」
==
- 目的は同じだが中身の違う関数を、同じ名前で定義する。
- 呼び出す側（クラスを利用する側）での呼び出し方を変える必要がない。
- 関数の再利用がしやすくなる。
## これまた「変更しやすい」プログラムを作るための仕組み

---
オブジェクト指向３大要素
==
## 継承
- 既存のクラスの機能を拡張して、新しいクラスを作る
## ポリモーフィズム
- 中身の違が目的が同じ関数を同じ名前で定義できる
## カプセル化
- あれ、カプセル化は・・・？

---
また攻撃力の関数の例
==
```
get_atk()
```
- この関数を使うと、**なんだかよくわかんないけど**、キャラの攻撃力がもらえる。
- キャラが剣士の場合は剣の攻撃力が、魔道士の場合は魔法での攻撃力が返却される
	> ポリモーフィズムのおかげ

---
これぞ「カプセル化」
==
- クラスや関数は、入力と出力の仕様だけ決めておく
- クラスや関数を使う側は、どんな処理がされているかを知る必要がない
### = クラスや関数の処理内容を、自由に変更することができる。
## これまた！「変更しやすい」プログラムを作るための仕組み
> ネットワークの「レイヤ分け」も同じ考え方です。
- お互いの処理内容に干渉せずにデータのやり取りを行うシステムを**疎結合**なシステムと呼ぶ

---
オブジェクト指向３大要素
==
## 継承
- 既存のクラスの機能を拡張して、新しいクラスを作る。
## ポリモーフィズム
- 中身の違うメソッドを同じ名前で定義して、利用しやすくする。
## カプセル化
- クラスや関数を使う側が、処理内容を意識しないでよい

## 覚えて帰ろう！変更しやすいプログラムを作る３大要素！

---
おまけ
==
## メソッドについて
- クラスの中に書かれた関数のことを「メソッド」と呼ぶ
- 呼び方が違うだけで、関数と同じ

## カプセル化の補足
- クラスのプロパティ（jin.hpのhpなど）への直接のアクセスを禁止することも含む
	- クラス外から意図せず値を変更されることがバグの発生につながるから
- pythonでは、プロパティへの直接アクセスを制限していない

---
おまけその２
==

## swd(sword、剣)という変数名は非常にイケてないです。
```
class Chara {
 name
 hp
 lv
 str
 vit
 swd <-これ
 arm

 def get_atk() //攻撃力を計算する関数
 return Chara.lv * (Chara.str + Chara.swd)
```
- なぜでしょうか

---
答え
==

## 「剣」の攻撃力以外を代入しにくくなる
- 武器が「槍」「弓」「三節棍」「ボウガン」「M4 SOPMOD」「DSR-1（.338ラプアマグナム）」といった、剣でないものの攻撃力を入れるときに違和感を感じる（剣じゃないのにswdなの・・・？）
### （オブジェクト指向に限らず）プログラミングするときは、「可能な限り抽象的な命名」を心がけましょう！

---

Pythonをもっともっと知ろう
==

---

Pythonでのクラスの使いみち
==
- Pythonはクラスを書かなくても実行可能コードが書けますが・・・
- こんなときに使うと便利です
#### データを保持する
- ファイルを読み込んでその中身を持つ
#### データとそれに対する処理をまとめる
- RPGのキャラ、社員名簿など、共通のステータスを持った複数のレコードと、それに対する処理を持つ
#### 似たような処理をまとめて管理する
- いろんな計算をする関数をまとめる
> データを持たずに関数だけを提供するクラスをユーティリティクラスといいます。データを持たないのでインスタンス化せずに使えます

---

Pythonクラスとインスタンスの実例
==

- クラス作成
```
class human: 
    def __init__(self,name): 
        self.name = name 
    def get_name(self): 
        return self.name 
```
- インスタンス化
```
jin = human("jin")                                                                           
```
- メソッドの利用
```
print(jin.get_name()) # jin
```

---

self って何？？
==

---

def \_\_init__(self): って何？？
==
### これはコンストラクタです
- インスタンス化するときに、仮引数をインスタンスに格納するためのもの
- インスタンス化した時に自動で実行されるメソッド
- 値を入れる他、インスタンス化したときに実行したいメソッドを書いてもOK
- インスタンス化しないクラス（ユーティリティクラス）には不要
- インスタンスが破棄される時に自動で実行される、デストラクタというのもある

---

Pythonプログラムの構造化
==

- 一度しか使わないような、１０行程度のスクリプトは別ですが、、、
### コードを書く時は構造化を心がけましょう
- 構造化の例
```
class hoge:     # 具体的な処理内容はクラスにまとめる
    def hoge:
    # ホゲの処理

def main():     # クラスを利用するメイン関数はmain()に
    h = hoge()
    # メインの処理
    return 0

if __name__ == "__main__":  # スクリプト実行時にmain()を呼び出す
    import sys
    sys.exit(main())
```

---

構造化するのはなんのため
==
### モジュールとして使えるようにする
- 他のコードから呼び出せるように、処理に名前をつける
- コードが長くなってきたり、使いまわせそうな処理が増えてきたらモジュール化しましょう
### テストをしやすくする
- 処理は細かく分けてあったほうがテストがしやすい
- テストコードから呼び出せるように名前をつける
### 単に見やすくなる
- ダラーッと処理が書いてあるよりも見やすい
- 見やすいコードはメンテもしやすい

---

クラスは部品
==
- クラスに書かれるのは、プログラムを構成する部品
- 巨大なプログラムは、細かい部品クラスの集まりで書かれている
	- 細かい部品から車が作られているのと同じ
	- 部品単位に別れている方がメンテナンスや改修がしやすい
- 一つのクラスや関数に処理を書いてしまうのではなく、再利用を考慮した部品単位に分けよう
	- ファイルを読み込んで、書式を確認して、全行を保持するクラス
	- あるwebサービスの認証情報と情報を保持するクラス
- プログラム起動時に最初に呼び出される部分＝メイン関数に、これらのクラスを利用する処理を書く

---

if \_\_name__ == "\_\_main__": って何
==
- \_\_name__は、Pythonの組み込み変数
#### 以下の場合、\_\_name__には"\_\_main__"が入る
- **python3 hoge.pyみたいに実行されたとき**
- 標準入力からモジュールが読み込まれた時
- REPLを使った時 
#### モジュールとして読み込んだときには、モジュール名が入る
### つまり、メイン処理として呼び出されたときの処理を書くのに向いている 
- python3 xx.pyとして実行するときに一番最初に実行されるとこ、くらいの認識で一旦OK、ですが・・

---

if \_\_name__ == "\_\_main__":からmain()を呼び出してる意味
==
```
def main():     # クラスを利用するメイン関数はmain()に
    # メインの処理
if __name__ == "__main__":  # スクリプト実行時にmain()を呼び出す
    sys.exit(main())
```
- クラスや関数の外にある変数は、全てグローバル変数となる
- クラスや関数内で変数が見つからなかった場合、グローバル空間に変数を探しに行く
- もしそこで、たまたま変数が見つかってしまったら・・・
- main処理自体も関数内に閉じ込めておくことで、無駄なグローバル変数が増えることを防ぐ
- Pycharmは、グローバル空間にある変数名をローカルで使おうとすると、静的解析時に警告してくる

---
jsonについて
==
- JavaScript Object Notationの略
- もともとは、Javascriptでデータ構造を書くための書式
- webAPIでデータをやり取りするときの事実上の標準規格
- jsonの例
```json
{
  "name": "JK",
  "blood-type": "A",
  "favorites": ["tech","music","instruments"]
}
```
- 

---

Pythonでjson
==
- 用途に応じて、相互に変換する必要がある
- jsonを取り扱うには、jsonモジュールをインポートする必要がある
##### jsonファイルを読み込んで辞書にする
```python
json.load()
```
##### 辞書からjsonファイルに書き出す
```python
json.dump()
```
- json形式でファイルを扱いたい場合に利用する
---

Pythonでjson（続き）
==
- ファイルに書き出さずにコード内だけで文字列に変換が必要な場合は以下を利用する
- webでのデータやり取りはjson文字列なため、webアクセスする際はjsonへの変換が必要になる
##### json文字列を辞書にする
```python
json.loads()
```
##### 辞書をjson文字列にする
```python
json.dumps()
```
- 最後にsが付いているのは文字列に変換、と覚えるとよい

---

tocaroボット作成講座
==

---

HTTPおさらい
==

---

HTTPとは
==
- HyperTextTransferProtocolの略
    - HyperTextとは、あるテキストから他のテキストに接続できる仕組みを持ったテキストのこと
    > 言うまでもなく、今日ではハイパーテキストとはHTMLドキュメントのことを指します
- 原案までたどると1945年まで遡るが、スイスCERNで1990年に開発されたWWWで一気に脚光を浴びた
    - ちなみに世界最初のwebページはこれ
    [World Wide Web](http://info.cern.ch/hypertext/WWW/TheProject.html)
- インターネット普及の立役者で、DNSとともに今日のインターネットの根幹技術である

---

HTTPとは（続き）
==

- クライアント・サーバモデルで提供される
    - サーバはハイパーテキストと、そこから読み込まれるコンテンツを保持・提供・更新ための仕組みを持つ
    - クライアントは、サーバにコマンドを発行してハイパーテキストとコンテンツを取り扱う
    > 一般的には、クライアントはwebブラウザを指す
- HTTP/2やwebsocketなど技術革新が非常に盛ん。コンテンツの転送をUDPで超高速に行ったり、サーバからの呼び出しもできるようになった 
- ブラウザ上で動くコードは長年Javascriptのみだったが、最近はネイティブコードが動くようになり、高度・高速なアプリケーションを動かせるようになってきている

---

HTTPメソッド
==
- HTTPサーバに発行する命令のこと
- コンテンツ（ハイパーテキストや画像など）の取得、作成、更新、削除を指示する
### GETメソッド
- サーバからコンテンツを取得する
### POSTメソット
- サーバにコンテンツを新規に配置する
### PUT/PATCHメソッド
- 配置済みのコンテンツを更新する
> ２つのメソッドの動きは全然違うのですがそれはまたいずれ・・・
### DELETEメソッド
- コンテンツを削除する

---
webAPIとは
==
### そもそもAPIって・・？
- あるプログラムから他のプログラムの機能を利用するための仕組み
	- アプリケーションからデータベースを操作するとか
	- グラフィックを描画するためのライブラリを利用するとか
	- ファイル操作やプロセス操作などOSの提供する機能もAPIと呼ぶ
### HTTP経由でAPIを使えるのがwebAPI
- APIへのアクセスをHTTPで行う
- APIを持っているwebサービスは結構多い
	- NHK番組表
	- 天気予報API
	- githubとか

---

APIが使えると何がいいのか
==
### 自動化できる
- 例えば、

### サービスを拡充できる
- テレビ番組と天気から

---

tocaroボット作成編
==

---

チャットボットとは
==

- チャットアプリやSNSを通じて、人間と対話するソフトウェアのこと
- 歴史は古く、1960年代には実験的なものがあった
- iPhoneのSiri，AIりんな、「お前を消す方法」のMSオフィスのカイルなどが有名
- 宅配便の再配達受付やwebサイトのユーザーサポートなど、普段の生活の中で見る機会も多い
- メッセージの自動投稿など、一方的に情報を提示するものは「ボット」と呼ばれ、チャットボットとは別物
	- チャットアプリがメッセージを受け付けるための仕組みをincomming webhookと呼ぶ
	- tocaroにメッセージを投稿するのもこれを利用

---

ボットの例
==
### おすすめランチボット
- お昼頃に今日のランチを勧めてくれる
	- 会社近くのお店を自動収集してデータベース化する
	- データベースからランダムで店を抽出する
	- メッセージを作成して、tocaroに投げる
### セミナー教えてくれボット
- IT系セミナーの開催予定を教えてくれる
	- セミナー紹介サイトからセミナーのデータベースを作る
	- 以下、上と同じ
#### ネタはいっぱいありそうですね！

---

tocaroでボットに挑戦
==
- まずは難易度の低い、tocaroグループに投稿するだけのボットを作成
#### tocaroグループへの投稿の仕方
1. 投稿を表示するtocaroグループを作成（各自で実施済みのはず）
2. 作成したグループにて、投稿用URLを発行
3. 投稿するメッセージをPython辞書型で構成
4. 投稿用URLにメッセージ辞書をPOSTする
#### 以上！簡単！

---

URL取得
==
- 以下を参考に、webhookURL（投稿用URL）を取得してください
[tocaro公式ブログ-Zabbixのメッセージをtocaroに流してみよう](
https://jp.tocalog.com/post/142731280596/zabbix%E3%81%AE%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%82%92tocaro%E3%81%AB%E6%B5%81%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86)
> 他にも、webhookURLの取得を紹介したサイトはたくさんあります
- 取得したURLはなくさないようにテキストファイルに貼り付けるかしておいてください
> もし消えた場合は、tocaroから再取得してください

---

tocaroメッセージを用意
==
- tocaro webhookのデータ書式は以下の通り。辞書型（josn）で作る
```python
{
  "text": "str" # 文字列型で好きなタイトル（大項目）を記載,
  "color": "color" # メッセージの左脇に付くバーの色を決める,
  "attachments": [　 # リストでメッセージを記載。要素は文字列型で、1要素＝1行
      {
        "title":文字列で項目名,
         "value":文字列
      },
        "title":文字列で項目名,
         "value":文字列
      }
      ]
}
```

---

メッセージ例
==
```
今日のお天気
｜・関東地方
｜　東京：晴　横浜：曇
｜・東海地方
｜　静岡：曇　名古屋：雨
```
```python
message = {
  "text": "今日のお天気",
  "color": "danger",
  "attachiments":
  [
    {
      "title": "・関東地方",
      "value": "　東京：晴　横浜：曇"
    },
    {
      "title": "・東海地方",
      "value": "　静岡：曇　名古屋：雨"
    }
  ]
}
```


---

tocaroへの投稿
==

```python
import urllib.request
import json

tocaro_url = 'https://hooks.tocaro.im/integrations/inbound_webhook/XXXXXXXXXX'

headers = {'Content-type': 'application/json'}
data = json.dumps(messsage).encode()

request = urllib.request.Request(tocaro_url, data, headers)

with urllib.request.urlopen(request) as response:
    body = response.read()
```
#### urllib.requestライブラリを利用する
- リクエスト内容として、接続先サーバのURLと、投稿内容(content) 、HTTPヘッダをrequest変数に設定する
- request変数をurlopen関数で開くと、指定したURLへアクセスされ、レスポンスがresponse変数に返る
---

urllib.reqestライブラリについて
==
- Python3標準の、HTTPクライアントライブラリ
- RequestメソッドでHTTPリクエストのオブジェクトを作成し、urlopenメソッドでリクエストを発行する
- レスポンスはオブジェクト（インスタンス）として返るので、そこからレスポンスボディなどを取り出して利用する
- urllib.requestの第2仮引数はdataで、POST時のコンテンツを設定する。dataがある場合はPOST,ない場合はGETリクエストをする
	> 他のメソッドも利用できますが本日は割愛
- headers仮引数には、HTTPヘッダを辞書型で設定する
	- dataがある場合（POSTの場合）、dataがjsonであることをサーバに伝えるため、"{'Content-type': 'application/json'}"を設定する

---

urllib.reqestライブラリについて（つづき）
==

- dataはjson形式でのみ受け付けるため、Pythonの辞書型をjson.dumpsで文字列型に変換する必要がある
- さらに、dataはバイト列である必要があるため。.encode()メソッドでバイト列に変換する必要がある 
```
data = json.dumps(messsage).encode()
```
### ややこしいですがそういうもんだと思ってください
- ちなみに、もっと簡単にHTTPを扱えるrequestsというモジュールもある。ただしPython3の標準ではないため、別途pipでインストールする必要がある


---

では、実際にメッセージを送ってみましょう！
==

OK, let's code!

---

（まとめを兼ねて）チャットボット作成ヒント
==
- チャットボットは双方向に会話する必要があるので、ボットよりも複雑になります
### チャットボットに必要な部品
- tocaroからのコマンドを受け付けるwebAPI
	> 次回勉強会で取り上げる予定です
- 会話の元になるデータベースと、それを管理するコード
	- お昼ごはんを教えて！というチャットボットを作る場合は、店舗の情報をまとめたDBを作るなど
- tocaroにメッセージを投げるコード
	- 今日作ったものが応用できます




---

本日もありがとうございました
==

### アンケートにご協力ください
