<!-- page_number: true -->
<!-- $theme: default -->
<!-- $size: 16:9 -->

FY19 VORTEX FUNトレーニング
Pythonスキルアップチーム勉強会
==

## 第2回
2019.10.17

---

本日のアジェンダ
==

### オブジェクト指向とは
### Pythonをもっともっと知ろう
###  tocaroボット作成講座

---

オブジェクト指向とは
==

---

オブジェクト指向とは
==
# 変更しやすいプログラムを作る手法のこと

---
例えば
==
#### 大規模な業務システムなどは、
- 数百万行のコード　から成り、
- プログラマー　が何十人と関わって、
- 機能拡張やバグ取り　を何度もしながら、
- 数年間　使う。
### 変更しやすいことは、とても重要！！
- これだけのことなのですが「オブジェクト指向」という名前のせいで「理解しがたいもの」になってます。

---
ちなみに
==
オブジェクト指向の生みの親、アラン・ケイ曰く
![150%](./alankay.jpeg)
「オブジェクト指向（Object Oriented）という名前を付けたのは失敗だった、**メッセージ指向**にすればよかった、、」と悔やんだそうですが、どっちでも同じ未来だった気がします。

---
なお、
==
元宝塚スターの「安蘭けい」とは関係ありません。
![150%](./keiaran.jpg)

---

では早速オブジェクト指向を実践しようか。。。
==
- しかし立ちはだかる謎用語たち
## クラス・インスタンス
## ポリモーフィズム
## インターフェース
## 継承、インジェクション、カプセル化・・・
# ？？？

---

で、「今更聞けないオブジェクト指向」的なサイトにいくと・・・
==

### クラスとは、インスタンスの設計図で、いわばたい焼きの型のようなものです。インスタンスは、クラスから作られる、たい焼きのようなものなのです！！（バァァアン！）
##### クラスからインスタンスができるのは、それはわかるんだけど・・・
- そもそもなぜクラスというものが必要なのかがわからない
- 変更しやすいプログラムを作ることと、たい焼きが結びつかない
## 大丈夫です
## なぜオブジェクト指向が必要なのか、なぜ変更しやすいプログラムが作れるのかを、これから解説いたします

---

んじゃ、突然ですがRPGを作ります
==

---
といってもこんなのではなく・・・
==

![80%](./FF13.jpg)

---
レトロなやつ
==
![70%](./dq1.jpg)
こういうのをイメージしてください。
しかも戦闘シーンのみ

---
勇者プロフィール
==

### 勇者じん
- おひつじ座　43歳
```
jin_name = "じん"
jin_hp = 10
jin_lv = 43
jin_str = 5
```
- ステータスはこんな感じ。

---
敵プロフィール
==

### スライム
- 永遠のやられ役
```
slime_name = "スライム"
slime_hp = 5
slime_lv = 1
slime_str = 1
```

---
戦闘プログラム
==

```
jin_name = "じん"
jin_hp = 10
jin_lv = 42
jin_str = 5

slime_name = "スライム"
slime_hp = 5
slime_lv = 1
slime_str = 1

# じんかスライムのどちらかのHPがゼロになるまで繰り返し
while jin_hp > 0 or slime_hp > 0:
 slime_hp = slime_hp - (jin_lv * jin_str)
 jin_hp = jin_hp - (slime_lv * slime_str)

HPが残ってる方の人を表示（処理は省略）
```
> スライム瞬殺ですがあまり気にしないでください。そこは本編とは関係ありません。

---
勇者とスライム以外出てこーへんのかこのゲームは。
==

はっはい対応します。

---
対応しました
==
```
jin_name = "じん"
jin_hp = 10
jin_lv = 42
jin_str = 5

slime_name = "スライム"
slime_hp = 5
slime_lv = 1
slime_str = 1

drakee_name = "ドラキー"
drakee_hp = 7
drakee_lv = 2
drakee_str = 2

ランダムで敵を選ぶ処理（省略）
　じんかスライムのどちらかのHPがゼロになるまで繰り返し：
　じんかドラキーのどちらかのHPがゼロになるまで繰り返し：
　※処理は省略
```

---
全部の敵の処理を書いていくつもりか
==
ですよね ^ ^;

---
勝敗の判定を関数にしてみる
==

```
def 勝敗判定（勇者_name, 勇者_hp,勇者_lv,勇者_str,敵_name, 敵_hp,敵_lv,敵_str）
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵_hp = 敵_hp - (勇者_lv * 勇者_str)
  勇者_hp = 勇者_hp - (敵_lv * 敵_str)
 return 勝った方のname
```
```
jin_hp = 10
※以下省略

slime_hp = 5
※以下省略

drakee_hp = 7
※以下省略

# スライムがあらわれた！
winner = 勝敗判定(jin_name,jin_hp,jin_lv,jin_str,slime_name, sime_hp,slime_lv,slime_str) 
print(winner)
```

---
コードが読みにくい・・・
==
```
winner = 勝敗判定(jin_name,jin_hp,jin_lv,jin_str,slime_name, sime_hp,slime_lv,slime_str) 
```
- 関数に渡す値が多すぎるな・・・と思っていると・・・

---
息を切らしてゲームデザイナーが登場
==

「すみません！防御力のこと忘れてました！ハァハァ」
「・・・（まじか）」

- 防御力の変数(_vit)を追加。

```
def 勝敗判定（勇者_name,勇者_hp,勇者_lv,勇者_str,勇者_vit, 敵_name, 敵_hp,敵_lv,敵_str,敵_vit）
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵_hp = 敵_hp - (勇者_lv * 勇者_str - 敵_vit)
  勇者_hp = 勇者_hp - (敵_lv * 敵_str - 勇者_vit)
```
#### 破綻の予感がする。
- 「すばやさ」とか他のステータスが増えたらさらに長くなる。
- 味方や敵が団体の場合どうなるん・・・

---

何が問題かを整理してみる
==
### キャラの数 * ステータスの数だけ変数がある。
- jin_hp、slime_lvなど・・・
### 勝敗判定の関数に渡す値がどんどん増える（あるいは減る）
- 単純にめちゃ見にくい問題
- 変更があった場合、勝敗判定の関数を呼び出す側も、勝敗判定の関数そのものも、両方のプログラムを変えないといけない。

---

頭のいい人達が考えました
==

## ステータスをひとまとめにした変数「Chara」を作ったらええんや！
```
ひとまとめ Chara {
 name
 hp
 lv
 str
 vit
}
```
### 名付けて「ひとまとめ機能」
- キャラのステータスという**個性**をまとめて管理できる。

---
「ひとまとめ機能」を使ってみる
==
- まず、jinとかslimeとかいう名前で使うことを声高らかに宣言

```
ひとまとめ Chara jin
ひとまとめ Chara slime
```
- その後、各ステータスの値を設定
```
jin.name = "じん"
jin.hp = 10
jin.lv = 43
jin.str = 5
jin.vit = 5

slime.name = "スライム"
slime.hp = 5
slime.lv = 1
※以下略
```

---
使い方は従来と変わらない
==
-  「 _ 」 が「 . 」 になっただけ

```
jin.hp = 10
slime.hp = 5

print(jin.hp) // 10と表示される
print(slime.hp) // 5と表示される
```
- 結局、キャラとステータスの数だけ変数を設定していて、変わったように見えないんだけど・・・

---
勝敗判定の関数に渡す変数が少なくて済む
==
```
// スライムがあらわれた！
勝敗判定(jin,slime)
```
```
def 勝敗判定（勇者,敵）
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵.hp = 敵.hp - (勇者.lv * 勇者.str - 敵.vit)
  勇者.hp = 勇者.hp - (敵.lv * 敵.str - 勇者.vit)
```
- 変数「jin」や「slime」に、全ステータスが入っているのでjinやslimeだけを渡せばOK。
- 各ステータスは「 . 」を使って、関数の中で取り出す。
### だいぶ楽になったな・・・と思っていると

---
例のデザイナーが走ってきました。
==

「すみません！！剣と鎧のこと忘れてました！ハァハァ」
「・・・（裸か勇者）」
### 大丈夫です。ひとまとめ機能を得てますので

- ひとまとめ機能に、剣と鎧を追加する。
```
ひとまとめ Chara {
 hp
 lv
 str
 vit
 swd // 剣を追加
 arm // 鎧を追加
}
```

---
勝敗判定の関数にも、剣と鎧を追加。でも、、、
==
- 関数の呼び出し側や、受け取る側も、剣と鎧を増やさなくてもいいけど・・・
```
// スライムがあらわれた！
勝敗判定(jin,slime)
```
```
関数 勝敗判定（勇者,敵）:
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵.hp = 敵.hp - (勇者.lv * (勇者.str + 勇者.swd) - 敵.lv * (敵.def + 敵.arm))
  勇者.hp = 勇者.hp - (敵.lv * (敵.str + 敵.swd) - 勇者.lv * (勇者.def + 勇者.arm))
```
### これまた破綻の予感
- ダメージの計算は書き換えないといけない
- 「なんとかスキル」とかが増えたらダメージの計算が長くなる。

---
ふと思ふ
==

- キャラの攻撃力や防御力は、HPやレベルと同じで**キャラの個性**。
- キャラの個性を管理している「ひとまとめ」の中で計算してもらって、その結果を貰えばよいのでは？

---
頭のいい人たちが助けてくれた
==
- ひとまとめ機能がパワーアップして、計算ができるようになりました。

```
ひとまとめ Chara {
 hp
 lv
 str
 vit
 swd
 arm

 def 攻撃力() //攻撃力を計算する関数
  return  lv * (str + swd)

 def 防御力() //防御力を計算する関数
  return lv * (vit + arm)
}
```
---
使い方はいままでと同じ
==
- ひとまとめ機能の変数は、以下で利用できた。
```
ひとまとめ Chara jin
jin.hp = 10
print(jin.hp) //10と表示される。
```
- 計算の仕方も同じ。
```
jin.swd = 3
print(jin.攻撃力()) //jinの攻撃力 43*(5+3)=344 が表示される。
```
### これでどうなるかというと・・・

---
勝敗判定の関数が見やすくなった
==
```
関数 勝敗判定（勇者,敵）:
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵.hp = 敵.hp - (勇者.攻撃力() - 敵.防御力())
  勇者.hp = 勇者.hp - (敵.攻撃力() - 勇者.防御力())
```
#### ごちゃごちゃした計算式がなくなった
- 勝敗判定の関数内で、ダメージを計算するのをやめた
- それぞれのキャラに対して「攻撃力と防御力を教えて」と聞くように変えた

---
見やすくなったのは実はオマケ
==
## 「ダメージの計算」と「勝敗の判定」を分けられたことがポイント
- 攻撃力の計算方法を変えるときは、**攻撃力( )関数**の中身だけを変えればよくなった。
- 逆に、勝敗の判定方法を変えるときに、ダメージの計算部分を気にしなくてよくなった。
## 変更する箇所を狭くすることができた　＝　変更しやすいプログラムになった！！
#### ひとまとめ機能すごい！

---
「ひとまとめ機能」の良さが分かったので
==
## ようやくオブジェクト指向用語の登場
## ひとまとめ機能　＝　クラス
- データ(キャラのステータス)とそれに対する処理（攻撃力と防御力の計算）をまとめたもの
- いわばキャラの「設計図」
```
class Chara {
 name
 hp
 lv
 ...
 def get_atk_point()
 def get_def_point()
 ...
}
```

---
インスタンスとは
==
## クラスに具体的な値を入れたもの
- クラス自体はただの設計図なので、具体的な値を持っていない。
- 具体的な値を持ったキャラがほしいときに、インスタンスを新しく作る。
```
jin = new Chara() //ひとまとめ Chara jin
jin.hp = 10
jin.lv = 42
```
### メリット
- 勇者とかスライムとか、共通のステータス名を持ったキャラを大量に作れる。　=　**jin_hpとかslime_hpとか、キャラ * ステータスの数だけ変数を持たなくてもよくなる**。

---
たい焼きの例よりわかりやすいんじゃないでしょうか
==

---
そしてお気づきの通り
==

クラス、関数、インスタンス、jin、slime、drakee、その他敵
## ↑これ全部が、オブジェクト

## オブジェクトを使って、変更しやすいプログラムを作る　＝　オブジェクト指向プログラミング
> どこまでをオブジェクトと呼ぶかは言語の仕様によって異なります。例えばpythonでは全てがオブジェクトです。

---
オブジェクト指向言語
==
## オブジェクト指向を導入しやすくした言語　＝　オブジェクト指向言語
- オブジェクト指向言語でなくても、頑張ればオブジェクト指向することはできる。
- しかし言語の仕様として無いと、大変めんどくさい・・・

---
例のデザイナー登場
==

「すいません！魔法のこと忘れてましたァァァ！」
「・・・（魔法忘れるなよ）」

## 安心してください。オブジェクト指向がありますよ。

---
魔道士も簡単にできる
==

```
class Magician extends Chara {
 mp
 matk // 魔法攻撃力
 mdef //魔法防御力

 def get_atk():
  return Chara.lv * Chara.matk
 def get_def():
  return Chara lv * Chara.mdef
}
```
- Charaのステータスを引き継いで（extends）、魔法に必要なステータスだけを定義。
- lvとかhpとか、Charaにあるものはそのまま使える。
- 攻撃力・防御力の計算式は、魔法を使ったものに変える。

---
これぞ「継承」
==
- あるクラスを引き継いで新しいクラスを作ることができる。
- 新しいクラスに必要になるものだけを追加すればよい。
- 同じ名前の関数を書くと、引継元クラスの関数を上書きしてくれる。
```
yuto = new Magician()
yuto.hp = 10
...
yuto.mp = 20
yuto.mat = 10
...
print(yuto.get_atk()) //yutoの魔法攻撃力が表示される。
```
## これも「変更しやすい」プログラムを作るための仕組み


---
関数名は変えなくていいんですか
==
```
get_atk()
```
- 戦士の場合・・・武器でぶん殴る。
- 魔道士の場合・・・魔法で焼いたり爆発させたりする。
- 計算方法が違うので、名前も変えたくなりますが・・・
## 方法は異なるが、「相手にダメージを与える」という目的は同じ = 関数名は同じであるべき。

---
攻撃方法によって名前が違うと大変
==
```
get_magic_atk()
```
```
勇者 = yuto
敵 = slime
def 勇者が魔道士の場合の勝敗判定（勇者,敵）:
 勇者か敵のどちらかのHPがゼロになるまで繰り返し：
  敵.hp = 敵.hp - (勇者.get_magic_atk() - 敵.get_def())
  勇者.hp = 勇者.hp - (敵.get_atk() - 勇者.get_def())
```
- キャラの攻撃方法によって、違う勝敗判定の関数を呼び出さないといけないなんて・・・イケてない！
- イケてないというか、関数の使いまわしが効かないのでこんなコードを書いてはいけません（関数にする意味がない）

## 目的が同じ関数は、中身が違っても同じ名前で呼び出したい！

---
これぞ「ポリモーフィズム（多態性）」
==
- 目的は同じだが中身の違う関数を、同じ名前で定義する。
- 呼び出す側（クラスを利用する側）のプログラムを変える必要がない。
- 関数の再利用がしやすくなる。
## これまた「変更しやすい」プログラムを作るための仕組み

---
オブジェクト指向３大要素
==
## 継承
- 既存のクラスの機能を拡張して、新しいクラスを作る。
## ポリモーフィズム
- 中身の違う関数を同じ名前で定義して、利用しやすくする。
## カプセル化
- あれ、カプセル化は・・・？

---
また攻撃力の関数の例
==
```
get_atk()
```
- この関数を使うと、**なんだかよくわかんないけど**、キャラの攻撃力がもらえる。
- この関数を使う側は、get_atk()の中でどんな計算をしているのか知る必要がない。
	- 物理攻撃なのか、魔法攻撃なのかとか。


---
これぞ「カプセル化」
==
- クラスや関数は、入力と出力の仕様だけ決めておく。
- クラスや関数を使う側は、どんな処理がされているかを知る必要がない。
### = クラスや関数の処理内容を、自由に変更することができる。
## これまた！「変更しやすい」プログラムを作るための仕組み
> ネットワークの「レイヤ分け」も同じ考え方です。

---
オブジェクト指向３大要素
==
## 継承
- 既存のクラスの機能を拡張して、新しいクラスを作る。
## ポリモーフィズム
- 中身の違うメソッドを同じ名前で定義して、利用しやすくする。
## カプセル化
- クラスや関数を使う側が、その中身を意識しなくてもよい。

## 覚えて帰ろう！変更しやすいプログラムを作る３大要素！


---
おまけ
==
## メソッドについて
- クラスの中に書かれた関数のことを「メソッド」といいます。
- 呼び方が違うだけで、関数と同じです。

## カプセル化の補足
- クラスのプロパティ（jin.hpのhpなど）への直接のアクセスを禁止することも含まれます。
- クラス外から意図せず値を変更されることがバグの発生につながるからです。
- pythonの様に、プロパティへの直接アクセスを制限していない言語もあります。

---
おまけその２
==

## swd(sword、剣)という変数名は非常にイケてないです。
```
class Chara {
 name
 hp
 lv
 str
 vit
 swd
 arm

 def get_atk() //攻撃力を計算する関数
 return Chara.lv * (Chara.str + Chara.swd)
```
- なぜでしょうか

---
答え
==

## 「剣」の攻撃力以外を代入しにくくなる
- 武器が「槍」「弓」「三節棍」「ボウガン」「M4 SOPMOD」「DSR-1（.338ラプアマグナム）」といった、剣でないものの攻撃力を入れるときに違和感を感じる（剣じゃないのにswdなの・・・？）
### （オブジェクト指向に限らず）プログラミングするときは、「可能な限り抽象的な命名」を心がけましょう！

---

Pythonをもっともっと知ろう
==

---

Pythonでは全てがオブジェクト
==


おぶじぇくととして送る、返るの意味



---
文字列とバイトデータとunicode


---
jsonについて
==


---

tocaroボット作成講座
==

---

HTTPおさらい
==

---

HTTPとは
==
- HyperTextTransferProtocolの略
    - HyperTextとは、あるテキストから他のテキストに接続できる仕組みを持ったテキストのこと
    > 言うまでもなく、今日ではハイパーテキストとはHTMLのことを指します
- 原案までたどると1945年まで遡るが、スイスCERNで1990年に開発されたWWWで一気に脚光を浴びた
    - ちなみに世界最初のwebページはこれ
    [World Wide Web](http://info.cern.ch/hypertext/WWW/TheProject.html)
- クライアント・サーバモデルで提供される
    - サーバはハイパーテキストを保持し、提供する
    - クライアントは、サーバにコマンドを発行してハイパーテキストを取得し、コンソールに表示する
- インターネット普及の立役者で、今日のインターネットの根幹にあり、機能拡張のスピードも非常に早い

---

HTTPのしくみ
==
- HTTPサーバに対して発行するコマンドのこと
- 




---

チャットボットとは
==

- チャットアプリやSNSを通じて、人間と対話するソフトウェアのこと
- 歴史は古く、1960年代には実験的なものがあった
- iPhoneのSiri，AIりんな、「お前を消す方法」のあのMSオフィスのカイルなどが有名
- 宅配便の再配達受付やwebサイトのユーザーサポートなど、普段の生活の中で見る機会も多い
- メッセージの自動投稿など、一方的に情報を提示するものは「ボット」と呼ばれ、チャットボットとは別物
	- チャットアプリがメッセージを受け付けるための仕組みをincomming webhookと呼ぶ
	- tocaroにメッセージを投稿するのもこれを利用

---

tocaroボット作成編
==

---

tocaroでボットに挑戦
==
- まずは難易度の低い、tocaroグループに投稿するだけのボットを作成
#### tocaroグループへの投稿の仕方
1. 投稿を表示するtocaroグループを作成（各自で実施済みのはず）
2. 作成したグループにて、投稿用URLを発行
3. 投稿するメッセージをPython辞書型で構成
4. 投稿用URLにメッセージ辞書をPOSTする
#### 以上！簡単！

---

URL取得
==
- 以下を参考に、webhookURL（投稿用URL）を取得してください
[tocaro公式ブログ-Zabbixのメッセージをtocaroに流してみよう](
https://jp.tocalog.com/post/142731280596/zabbix%E3%81%AE%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%82%92tocaro%E3%81%AB%E6%B5%81%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86)
> 他にも、webhookURLの取得を紹介したサイトはたくさんあります
- 取得したURLはなくさないようにテキストファイルに貼り付けるかしておいてください
> もし消えた場合は、tocaroから再取得してください

---

tocaroメッセージを用意
==
- tocaro webhookのデータ書式は以下の通り。辞書型（josn）で作る
```python
{
  "text": "str" # 文字列型で好きなタイトル（大項目）を記載,
  "color": "color" # メッセージの左脇に付くバーの色を決める,
  "attachments": [　 # リストでメッセージを記載。要素は文字列型で、1要素＝1行
      {
        "title":文字列で項目名,
         "value":文字列
      },
        "title":文字列で項目名,
         "value":文字列
      }
      ]
}
```

---

メッセージ例
==
```
今日のお天気
｜・関東地方
｜　東京：晴　横浜：曇
｜・東海地方
｜　静岡：曇　名古屋：雨
```
```python
message = {
  "text": "今日のお天気",
  "color": "danger",
  "attachiments":
  [
    {
      "title": "・関東地方",
      "value": "　東京：晴　横浜：曇"
    },
    {
      "title": "・東海地方",
      "value": "　静岡：曇　名古屋：雨"
    }
  ]
}
```


---

tocaroへの投稿
==

```python
import urllib.request
import json

tocaro_url = 'https://hooks.tocaro.im/integrations/inbound_webhook/XXXXXXXXXX'

headers = {'Content-type': 'application/json'}
data = json.dumps(messsage).encode()

request = urllib.request.Request(tocaro_url, data, headers)

with urllib.request.urlopen(request) as response:
    body = response.read()
```
#### urllib.requestライブラリを利用する
- リクエスト内容として、接続先サーバのURLと、投稿内容(content) 、HTTPヘッダをrequest変数に設定する
- request変数をurlopen関数で開くと、指定したURLへアクセスされ、レスポンスがresponse変数に返る
---

urllib.reqestライブラリについて
==
- Python3標準の、HTTPクライアントライブラリ
- RequestメソッドでHTTPリクエストのオブジェクトを作成し、urlopenメソッドでリクエストを発行する
- レスポンスはオブジェクトとして返るので、そこからレスポンスボディなどを取り出して利用する
- urllib.requestの第2仮引数はdataで、POST時のコンテンツを設定する。dataがある場合はPOST,ない場合はGETリクエストをする
- headers仮引数には、HTTPヘッダを辞書型で設定する
	- dataがある場合（POSTの場合）、dataがjsonであることをサーバに伝えるため、"{'Content-type': 'application/json'}"を設定する

---

urllib.reqestライブラリについて（つづき）
==

- dataはjson形式でのみ受け付けるため、Pythonの辞書型をjson.dumpsで文字列型に変換する必要がある
- さらに、dataはバイト列である必要があるため。.encode()メソッドでバイト列に変換する必要がある 
```
data = json.dumps(messsage).encode()
```
### ややこしいですがそういうもんだと思ってください
- ちなみに、もっと簡単にHTTPを扱えるrequestsというモジュールもある。ただしPython3の標準ではないため、別途pipでインストールする必要がある

--- 

---





片方向
双方向



本日もありがとうございました
==

### アンケートにご協力ください
